{
  "_args": [
    [
      {
        "hosted": {
          "directUrl": "https://raw.githubusercontent.com/avadhpatel/mongoosastic/master/package.json",
          "gitUrl": "git://github.com/avadhpatel/mongoosastic.git",
          "httpsUrl": "git+https://github.com/avadhpatel/mongoosastic.git",
          "shortcut": "github:avadhpatel/mongoosastic",
          "ssh": "git@github.com:avadhpatel/mongoosastic.git",
          "sshUrl": "git+ssh://git@github.com/avadhpatel/mongoosastic.git",
          "type": "github"
        },
        "name": null,
        "raw": "git+https://github.com/avadhpatel/mongoosastic",
        "rawSpec": "git+https://github.com/avadhpatel/mongoosastic",
        "scope": null,
        "spec": "git+https://github.com/avadhpatel/mongoosastic.git",
        "type": "hosted"
      },
      "C:\\Users\\USER\\Projects\\api-jostma"
    ]
  ],
  "_from": "git+https://github.com/avadhpatel/mongoosastic.git",
  "_id": "mongoosastic@4.3.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/mongoosastic",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/avadhpatel/mongoosastic/master/package.json",
      "gitUrl": "git://github.com/avadhpatel/mongoosastic.git",
      "httpsUrl": "git+https://github.com/avadhpatel/mongoosastic.git",
      "shortcut": "github:avadhpatel/mongoosastic",
      "ssh": "git@github.com:avadhpatel/mongoosastic.git",
      "sshUrl": "git+ssh://git@github.com/avadhpatel/mongoosastic.git",
      "type": "github"
    },
    "name": null,
    "raw": "git+https://github.com/avadhpatel/mongoosastic",
    "rawSpec": "git+https://github.com/avadhpatel/mongoosastic",
    "scope": null,
    "spec": "git+https://github.com/avadhpatel/mongoosastic.git",
    "type": "hosted"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git+https://github.com/avadhpatel/mongoosastic.git#00e82f4aa71860dc8d0e82062551e3803997e08e",
  "_shasum": "11468c0ceb1ce65148ab837ddf12175d5bee5d9e",
  "_shrinkwrap": null,
  "_spec": "git+https://github.com/avadhpatel/mongoosastic",
  "_where": "C:\\Users\\USER\\Projects\\api-jostma",
  "author": {
    "email": "james.r.carr@gmail.com",
    "name": "James R. Carr",
    "url": "http://blog.james-carr.org"
  },
  "bugs": {
    "url": "https://github.com/mongoosastic/mongoosastic/issues"
  },
  "contributors": [
    {
      "email": "alban.mouton@gmail.com",
      "name": "Alban Mouton"
    },
    {
      "email": "alexandre@gotoserv.com",
      "name": "Alexandre-io"
    },
    {
      "email": "andreas@nex9.com",
      "name": "Andreas Schmid"
    },
    {
      "email": "antoine.verger@speicher210.com",
      "name": "antoineverger"
    },
    {
      "email": "antoine.verger@speicher210.com",
      "name": "Antoine Verger"
    },
    {
      "email": "cyanidesign@gmail.com",
      "name": "Arseny Zarechnev"
    },
    {
      "email": "astro@spaceboyz.net",
      "name": "Astro"
    },
    {
      "email": "b96705008@gmail.com",
      "name": "b96705008"
    },
    {
      "email": "rlauer@gmail.com",
      "name": "Bob Lauer"
    },
    {
      "email": "bobrown101@gmail.com",
      "name": "Brady Brown"
    },
    {
      "email": "ckkinay@gmail.com",
      "name": "Can Kutlu Kinay"
    },
    {
      "email": "jacob.chapel@gmail.com",
      "name": "chapel"
    },
    {
      "email": "charlie@charlietilt.com",
      "name": "Charlie Tilt"
    },
    {
      "email": "reezer@reezer.org",
      "name": "Christian Sturm"
    },
    {
      "email": "jitowix@gmail.com",
      "name": "Christophe Wagner"
    },
    {
      "email": "lecong1225@gmail.com",
      "name": "cong88"
    },
    {
      "email": "daniel.rafaj@gmail.com",
      "name": "Daniel Rafaj"
    },
    {
      "email": "danteata@gmail.com",
      "name": "danteata"
    },
    {
      "email": "me@deedubs.com",
      "name": "Dan Williams"
    },
    {
      "email": "mahnunchik@gmail.com",
      "name": "Eugeny Vlasenko"
    },
    {
      "email": "nerofrancesco@hotmail.com",
      "name": "Francesco Nero"
    },
    {
      "email": "gabriel.mancini@gmail.com",
      "name": "gabrielmancini"
    },
    {
      "email": "gpearman@gmail.com",
      "name": "Gary Pearman"
    },
    {
      "email": "gpearman@gmail.com",
      "name": "gazsp"
    },
    {
      "email": "shankga@gmail.com",
      "name": "George"
    },
    {
      "email": "shankga@gmail.com",
      "name": "George Shank"
    },
    {
      "email": "guumaster@users.noreply.github.com",
      "name": "Gustavo"
    },
    {
      "email": "gustavo.marin@intelygenz.com",
      "name": "gustavo.marin"
    },
    {
      "email": "gustavoandresmarin@gmail.com",
      "name": "guumaster"
    },
    {
      "email": "guuweb@gmail.com",
      "name": "guumaster"
    },
    {
      "email": "huseyinbabal88@gmail.com",
      "name": "Hüseyin BABAL"
    },
    {
      "email": "huseyin.babal@eu.sony.com",
      "name": "Hüseyin BABAL"
    },
    {
      "email": "ignacio@glue.gl",
      "name": "Ignacio Lago"
    },
    {
      "email": "isaymeorg@gmail.com",
      "name": "isayme"
    },
    {
      "email": "jamescarr@VirtualBox.(none)",
      "name": "jamescarr",
      "url": "none"
    },
    {
      "email": "james.r.carr@gmail.com",
      "name": "James Carr"
    },
    {
      "email": "jdelibas@gmail.com",
      "name": "James"
    },
    {
      "email": "james.r.carr@gmail.com",
      "name": "James R. Carr"
    },
    {
      "email": "Jason.More@gmail.com",
      "name": "Jason More"
    },
    {
      "email": "jbdemonte@gmail.com",
      "name": "Jean-Baptiste Demonte"
    },
    {
      "email": "james.tuttle@matrixinsights.com",
      "name": "jetNull"
    },
    {
      "email": "jeresig@gmail.com",
      "name": "John Resig"
    },
    {
      "email": "jon@jbuckley.ca",
      "name": "Jon Buckley"
    },
    {
      "email": "jon.burgess@bundlestars.com",
      "name": "Jon Burgess"
    },
    {
      "email": "jonjburgess@gmail.com",
      "name": "Jon Burgess"
    },
    {
      "email": "jose.maza@rulesware.com",
      "name": "Jose Maza"
    },
    {
      "email": "kev1_2_tob@msn.com",
      "name": "ksavidetove"
    },
    {
      "email": "mathews.kyle@gmail.com",
      "name": "Kyle Mathews"
    },
    {
      "email": "marcos.sanz@13genius.com",
      "name": "Marcos Sanz"
    },
    {
      "email": "matt@mattaudesse.com",
      "name": "Matt Audesse"
    },
    {
      "email": "themichaek@gmail.com",
      "name": "Michael Hellein"
    },
    {
      "email": "nadeesha.cabral@gmail.com",
      "name": "Nadeesha Cabral"
    },
    {
      "email": "thenickperson@gmail.com",
      "name": "Nicolas McCurdy"
    },
    {
      "email": "nico.schloemer@gmail.com",
      "name": "Nico Schlömer"
    },
    {
      "email": "nospam1@thomasson.fr",
      "name": "nlko"
    },
    {
      "email": "nvartolomei@gmail.com",
      "name": "nvartolomei"
    },
    {
      "email": "phill.rosen@gmail.com",
      "name": "Phillip Rosen"
    },
    {
      "email": "py09mb@users.noreply.github.com",
      "name": "py09mb"
    },
    {
      "email": "kai-uwe.renner@hbv83032616.bauer-de.bauermedia.group",
      "name": "Renner"
    },
    {
      "email": "robert@bildungsweb.net",
      "name": "Robert Katzki"
    },
    {
      "email": "root@helloo-dev.home",
      "name": "root"
    },
    {
      "email": "yoitsro@hotmail.com",
      "name": "Ro Ramtohul"
    },
    {
      "email": "samypesse@gmail.com",
      "name": "Samy Pessé"
    },
    {
      "email": "sascha@evolved.io",
      "name": "Sascha Schwabbauer"
    },
    {
      "email": "srfrnk@gmail.com",
      "name": "Srfrnk"
    },
    {
      "email": "will.jk01@gmail.com",
      "name": "stickycube"
    },
    {
      "email": "sukru@sukrubezen.com",
      "name": "Sukru BEZEN"
    },
    {
      "email": "shankga@gmail.com",
      "name": "taterbase"
    },
    {
      "email": "vin.boucher@gmail.com",
      "name": "Vincent Boucher"
    },
    {
      "email": "warner@clipppr.com",
      "name": "Warner Onstine"
    },
    {
      "email": "will.jk01@gmail.com",
      "name": "Will Knowles"
    },
    {
      "email": "kevin.wang@cloudera.com",
      "name": "xizhao"
    },
    {
      "email": "rex@bittorrent.com",
      "name": "xren"
    }
  ],
  "dependencies": {
    "elasticsearch": "14.1.0",
    "lodash.clonedeep": "4.5.0"
  },
  "description": "A mongoose plugin that indexes models into elastic search",
  "devDependencies": {
    "async": "2.5.0",
    "changelog": "^1.0.7",
    "co-mocha": "^1.1.3",
    "coveralls": "2.13.1",
    "eslint": "4.4.1",
    "eslint-config-standard": "6.2.1",
    "eslint-plugin-promise": "3.5.0",
    "eslint-plugin-standard": "3.0.1",
    "istanbul": "0.4.5",
    "mocha": "3.2.0",
    "mongoose": "4.11.8",
    "should": "12.0.0",
    "standard": "10.0.3"
  },
  "engines": {
    "node": ">= 4.0"
  },
  "gitHead": "00e82f4aa71860dc8d0e82062551e3803997e08e",
  "homepage": "https://github.com/mongoosastic/mongoosastic#readme",
  "license": "MIT",
  "main": "lib/mongoosastic.js",
  "name": "mongoosastic",
  "optionalDependencies": {},
  "readme": "# Mongoosastic\r\n[![Build Status](https://travis-ci.org/mongoosastic/mongoosastic.svg?branch=master)](https://travis-ci.org/mongoosastic/mongoosastic)\r\n[![NPM version](https://img.shields.io/npm/v/mongoosastic.svg)](https://www.npmjs.com/package/mongoosastic)\r\n[![Coverage Status](https://coveralls.io/repos/mongoosastic/mongoosastic/badge.svg?branch=master&service=github)](https://coveralls.io/github/mongoosastic/mongoosastic?branch=master)\r\n[![Downloads](https://img.shields.io/npm/dm/mongoosastic.svg)](https://www.npmjs.com/package/mongoosastic)\r\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/mongoosastic/mongoosastic?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\r\n\r\n[![NPM](https://nodei.co/npm/mongoosastic.png)](https://nodei.co/npm/mongoosastic/)\r\n\r\nMongoosastic is a [mongoose](http://mongoosejs.com/) plugin that can automatically index your models into [elasticsearch](https://www.elastic.co/).\r\n\r\n- [Installation](#installation)\r\n- [Setup](#setup)\r\n- [Indexing](#indexing)\r\n  - [Saving a document](#saving-a-document)\r\n  - [Removing a docuemnt](#removing-a-document)\r\n  - [Indexing nested models](#indexing-nested-models)\r\n  - [Indexing mongoose references](#indexing-mongoose-references)\r\n  - [Indexing an existing collection](#indexing-an-existing-collection)\r\n  - [Bulk indexing](#bulk-indexing)\r\n  - [Filtered indexing](#filtered-indexing)\r\n  - [Indexing on demand](#indexing-on-demand)\r\n  - [Unindexing on demand](#unindexing-on-demand)\r\n  - [Truncating an index](#truncating-an-index)\r\n  - [Restrictions](#restrictions)\r\n    - [Auto indexing](#auto-indexing)\r\n    - [Search immediately after es-indexed event](#search-immediately-after-es-indexed-event)\r\n- [Mapping](#mapping)\r\n  - [Geo mapping](#geo-mapping)\r\n    - [Indexing a geo point](#indexing-a-geo-point)\r\n    - [Indexing a geo shape](#indexing-a-geo-shape)\r\n  - [Creating mappings on-demand](#creating-mappings-on-demand)\r\n- [Queries](#queries)\r\n  - [Hydration](#hydration)\r\n\r\n## Installation\r\n\r\nThe latest version of this package will be as close as possible to the latest `elasticsearch` and `mongoose` packages.\r\n\r\n```bash\r\nnpm install -S mongoosastic\r\n```\r\n\r\n## Setup\r\n\r\n### Model.plugin(mongoosastic, options)\r\n\r\nOptions are:\r\n\r\n* `index` - the index in Elasticsearch to use. Defaults to the pluralization of the model name.\r\n* `type`  - the type this model represents in Elasticsearch. Defaults to the model name.\r\n* `esClient` - an existing Elasticsearch `Client` instance.\r\n* `hosts` - an array hosts Elasticsearch is running on.\r\n* `host` - the host Elasticsearch is running on\r\n* `port` - the port Elasticsearch is running on\r\n* `auth` - the authentication needed to reach Elasticsearch server. In the standard format of 'username:password'\r\n* `protocol` - the protocol the Elasticsearch server uses. Defaults to http\r\n* `hydrate` - whether or not to lookup results in mongodb before\r\n* `hydrateOptions` - options to pass into hydrate function\r\n* `bulk` - size and delay options for bulk indexing\r\n* `filter` - the function used for filtered indexing\r\n* `transform` - the function used to transform serialized document before indexing\r\n* `populate` - an Array of Mongoose populate options objects\r\n* `indexAutomatically` - allows indexing after model save to be disabled for when you need finer control over when documents are indexed. Defaults to true\r\n* `customProperties` - an object detailing additional properties which will be merged onto the type's default mapping when `createMapping` is called.\r\n* `saveOnSynchronize` - triggers Mongoose save (and pre-save) method when synchronizing a collection/index. Defaults to true\r\n\r\n\r\nTo have a model indexed into Elasticsearch simply add the plugin.\r\n\r\n```javascript\r\nvar mongoose     = require('mongoose')\r\n  , mongoosastic = require('mongoosastic')\r\n  , Schema       = mongoose.Schema\r\n\r\nvar User = new Schema({\r\n    name: String\r\n  , email: String\r\n  , city: String\r\n})\r\n\r\nUser.plugin(mongoosastic)\r\n```\r\n\r\nThis will by default simply use the pluralization of the model name as the index\r\nwhile using the model name itself as the type. So if you create a new\r\nUser object and save it, you can see it by navigating to\r\nhttp://localhost:9200/users/user/_search (this assumes Elasticsearch is\r\nrunning locally on port 9200).\r\n\r\nThe default behavior is all fields get indexed into Elasticsearch. This can be a little wasteful especially considering that\r\nthe document is now just being duplicated between mongodb and\r\nElasticsearch so you should consider opting to index only certain fields by specifying `es_indexed` on the\r\nfields you want to store:\r\n\r\n\r\n```javascript\r\nvar User = new Schema({\r\n    name: {type:String, es_indexed:true}\r\n  , email: String\r\n  , city: String\r\n})\r\n\r\nUser.plugin(mongoosastic)\r\n```\r\n\r\nIn this case only the name field will be indexed for searching.\r\n\r\nNow, by adding the plugin, the model will have a new method called\r\n`search` which can be used to make simple to complex searches. The `search`\r\nmethod accepts [standard Elasticsearch query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-queries.html)\r\n\r\n```javascript\r\nUser.search({\r\n  query_string: {\r\n    query: \"john\"\r\n  }\r\n}, function(err, results) {\r\n  // results here\r\n});\r\n\r\n```\r\n\r\nTo connect to more than one host, you can use an array of hosts.\r\n\r\n```javascript\r\nMyModel.plugin(mongoosastic, {\r\n  hosts: [\r\n    'localhost:9200',\r\n    'anotherhost:9200'\r\n  ]\r\n})\r\n```\r\n\r\nAlso, you can re-use an existing Elasticsearch `Client` instance\r\n\r\n```javascript\r\nvar esClient = new elasticsearch.Client({host: 'localhost:9200'});\r\nMyModel.plugin(mongoosastic, {\r\n  esClient: esClient\r\n})\r\n```\r\n\r\n\r\n## Indexing\r\n\r\n### Saving a document\r\nThe indexing takes place after saving in mongodb and is a deferred process.\r\nOne can check the end of the indexation by catching the es-indexed event.\r\n\r\n```javascript\r\ndoc.save(function(err){\r\n  if (err) throw err;\r\n  /* Document indexation on going */\r\n  doc.on('es-indexed', function(err, res){\r\n    if (err) throw err;\r\n    /* Document is indexed */\r\n    });\r\n  });\r\n```\r\n\r\n### Removing a document\r\nRemoving a document, or unindexing, takes place when a document is removed by calling `.remove()` on a mongoose Document instance.\r\nOne can check the end of the unindexing by catching the es-removed event.\r\n\r\n```javascript\r\ndoc.remove(function(err) {\r\n  if (err) throw err;\r\n  /* Document unindexing in the background */\r\n  doc.on('es-removed', function(err, res) {\r\n    if (err) throw err;\r\n    /* Docuemnt is unindexed */\r\n  });\r\n});\r\n```\r\n\r\nNote that use of `Model.remove` does not involve mongoose documents as outlined in the [documentation](http://mongoosejs.com/docs/api.html#model_Model.remove). Therefore, the following will not unindex the document.\r\n\r\n```javascript\r\nMyModel.remove({ _id: doc.id }, function(err) {\r\n  /* doc remains in Elasticsearch cluster */\r\n});\r\n```\r\n\r\n### Indexing Nested Models\r\nIn order to index nested models you can refer following example.\r\n\r\n```javascript\r\nvar Comment = new Schema({\r\n    title: String\r\n  , body: String\r\n  , author: String\r\n})\r\n\r\n\r\nvar User = new Schema({\r\n    name: {type:String, es_indexed:true}\r\n  , email: String\r\n  , city: String\r\n  , comments: {type:[Comment], es_indexed:true}\r\n})\r\n\r\nUser.plugin(mongoosastic)\r\n```\r\n\r\n### Elasticsearch [Nested datatype](https://www.elastic.co/guide/en/elasticsearch/reference/current/nested.html)\r\nSince the default in Elasticsearch is to take arrays and flatten them into objects,\r\nit can make it hard to write queries where you need to maintain the relationships\r\nbetween objects in the array, per .\r\nThe way to change this behavior is by changing the Elasticsearch type from `object`\r\n(the mongoosastic default) to `nested`\r\n\r\n```javascript\r\nvar Comment = new Schema({\r\n    title: String\r\n  , body: String\r\n  , author: String\r\n})\r\n\r\n\r\nvar User = new Schema({\r\n    name: {type: String, es_indexed: true}\r\n  , email: String\r\n  , city: String\r\n  , comments: {\r\n      type:[Comment],\r\n      es_indexed: true,\r\n      es_type: 'nested',\r\n      es_include_in_parent: true\r\n  }\r\n})\r\n\r\nUser.plugin(mongoosastic)\r\n```\r\n\r\n### Indexing Mongoose References\r\nIn order to index mongoose references you can refer following example.\r\n\r\n```javascript\r\nvar Comment = new Schema({\r\n    title: String\r\n  , body: String\r\n  , author: String\r\n});\r\n\r\n\r\nvar User = new Schema({\r\n    name: {type:String, es_indexed:true}\r\n  , email: String\r\n  , city: String\r\n  , comments: {type: Schema.Types.ObjectId, ref: 'Comment',\r\n    es_schema: Comment, es_indexed:true, es_select: 'title body'}\r\n})\r\n\r\nUser.plugin(mongoosastic, {\r\n  populate: [\r\n    {path: 'comments', select: 'title body'}\r\n  ]\r\n})\r\n```\r\nIn the schema you'll need to provide `es_schema` field - the referenced schema.\r\nBy default every field of the referenced schema will be mapped. Use `es_select` field to pick just specific fields.\r\n\r\n`populate` is an array of options objects you normally pass to\r\n[Model.populate](http://mongoosejs.com/docs/api.html#model_Model.populate).\r\n\r\n### Indexing An Existing Collection\r\nAlready have a mongodb collection that you'd like to index using this\r\nplugin? No problem! Simply call the synchronize method on your model to\r\nopen a mongoose stream and start indexing documents individually.\r\n\r\n```javascript\r\nvar BookSchema = new Schema({\r\n  title: String\r\n});\r\nBookSchema.plugin(mongoosastic);\r\n\r\nvar Book = mongoose.model('Book', BookSchema)\r\n  , stream = Book.synchronize()\r\n  , count = 0;\r\n\r\nstream.on('data', function(err, doc){\r\n  count++;\r\n});\r\nstream.on('close', function(){\r\n  console.log('indexed ' + count + ' documents!');\r\n});\r\nstream.on('error', function(err){\r\n  console.log(err);\r\n});\r\n```\r\n\r\nYou can also synchronize a subset of documents based on a query!\r\n\r\n```javascript\r\nvar stream = Book.synchronize({author: 'Arthur C. Clarke'})\r\n```\r\n\r\nAs well as specifying synchronization options\r\n\r\n```javascript\r\nvar stream = Book.synchronize({}, {saveOnSynchronize: true})\r\n```\r\n\r\nOptions are:\r\n\r\n * `saveOnSynchronize` - triggers Mongoose save (and pre-save) method when synchronizing a collection/index. Defaults to global `saveOnSynchronize` option\r\n\r\n\r\n### Bulk Indexing\r\n\r\nYou can also specify `bulk` options with mongoose which will utilize Elasticsearch's bulk indexing api. This will cause the `synchronize` function to use bulk indexing as well.\r\n\r\nMongoosastic will wait 1 second (or specified delay) until it has 1000 docs (or specified size) and then perform bulk indexing.\r\n\r\n```javascript\r\nBookSchema.plugin(mongoosastic, {\r\n  bulk: {\r\n    size: 10, // preferred number of docs to bulk index\r\n    delay: 100 //milliseconds to wait for enough docs to meet size constraint\r\n  }\r\n});\r\n```\r\n\r\n### Filtered Indexing\r\n\r\nYou can specify a filter function to index a model to Elasticsearch based on some specific conditions.\r\n\r\nFiltering function must return True for conditions that will ignore indexing to Elasticsearch.\r\n\r\n```javascript\r\nvar MovieSchema = new Schema({\r\n  title: {type: String},\r\n  genre: {type: String, enum: ['horror', 'action', 'adventure', 'other']}\r\n});\r\n\r\nMovieSchema.plugin(mongoosastic, {\r\n  filter: function(doc) {\r\n    return doc.genre === 'action';\r\n  }\r\n});\r\n```\r\n\r\nInstances of Movie model having 'action' as their genre will not be indexed to Elasticsearch.\r\n\r\n\r\n### Indexing On Demand\r\nYou can do on-demand indexes using the `index` function\r\n\r\n```javascript\r\nDude.findOne({name:'Jeffrey Lebowski', function(err, dude){\r\n  dude.awesome = true;\r\n  dude.index(function(err, res){\r\n    console.log(\"egads! I've been indexed!\");\r\n  });\r\n});\r\n```\r\n\r\nThe index method takes 2 arguments:\r\n\r\n* `options` (optional) - {index, type} - the index and type to publish to. Defaults to the standard index and type that\r\n  the model was setup with.\r\n* `callback` - callback function to be invoked when document has been\r\n  indexed.\r\n\r\nNote that indexing a model does not mean it will be persisted to\r\nmongodb. Use save for that.\r\n\r\n### Unindexing on demand\r\nYou can remove a document from the Elasticsearch cluster by using the `unIndex` function.\r\n\r\n```javascript\r\ndoc.unIndex(function(err) {\r\n  console.log(\"I've been removed from the cluster :(\");\r\n});\r\n```\r\n\r\nThe unIndex method takes 2 arguments:\r\n\r\n* `options` (optional) - {index, type} - the index and type to publish to. Defaults to the standard index and type that\r\n  the model was setup with.\r\n* `callback` - callback function to be invoked when model has been\r\n  unindexed.\r\n\r\n\r\n### Truncating an index\r\n\r\nThe static method `esTruncate` will delete all documents from the associated index. This method combined with `synchronize()` can be useful in case of integration tests for example when each test case needs a cleaned up index in Elasticsearch.\r\n\r\n```javascript\r\nGarbageModel.esTruncate(function(err){...});\r\n```\r\n\r\n### Restrictions\r\n\r\n#### Auto indexing\r\n\r\nMongoosastic try to auto index documents in favor of mongoose's [middleware](http://mongoosejs.com/docs/middleware.html) feature.\r\n\r\nMongoosastic will auto index when `document.save`/`Model.findOneAndUpdate`/`Model.insertMany`/`document.remove`/`Model.findOneAndRemove`, but not include `Model.remove`/`Model.update`.\r\n\r\nAnd you should have `new: true` options when `findOneAndUpdate` so that mongoosastic can get new values in post hook.\r\n\r\n#### Search immediately after es-indexed event\r\n\r\n> Elasticsearch by default refreshes each shard every 1s, so the document will be available to search 1s after indexing it.\r\n\r\nThe event `es-indexed` means that elasticsearch received the index request, and if you want to search the document, please try after 1s. See [Document not found immediately after it is saved ](https://github.com/elastic/elasticsearch-js/issues/231)\r\n\r\n## Mapping\r\n\r\nSchemas can be configured to have special options per field. These match\r\nwith the existing [field mapping configurations](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html) defined by Elasticsearch with the only difference being they are all prefixed by \"es_\".\r\n\r\nSo for example. If you wanted to index a book model and have the boost\r\nfor title set to 2.0 (giving it greater priority when searching) you'd\r\ndefine it as follows:\r\n\r\n```javascript\r\nvar BookSchema = new Schema({\r\n    title: {type:String, es_boost:2.0}\r\n  , author: {type:String, es_null_value:\"Unknown Author\"}\r\n  , publicationDate: {type:Date, es_type:'date'}\r\n});\r\n\r\n```\r\nThis example uses a few other mapping fields... such as null_value and\r\ntype (which overrides whatever value the schema type is, useful if you\r\nwant stronger typing such as float).\r\n\r\nThere are various mapping options that can be defined in Elasticsearch. Check out [https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html](https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html) for more information. Here are examples to the currently possible definitions in mongoosastic:\r\n\r\n```javascript\r\nvar ExampleSchema = new Schema({\r\n  // String (core type)\r\n  string: {type:String, es_boost:2.0},\r\n\r\n  // Number (core type)\r\n  number: {type:Number, es_type:'integer'},\r\n\r\n  // Date (core type)\r\n  date: {type:Date, es_type:'date'},\r\n\r\n  // Array type\r\n  array: {type:Array, es_type:'string'},\r\n\r\n  // Object type\r\n  object: {\r\n    field1: {type: String},\r\n    field2: {type: String}\r\n  },\r\n\r\n  // Nested type\r\n  nested: [SubSchema],\r\n\r\n  // Multi field type\r\n  multi_field: {\r\n    type: String,\r\n    es_type: 'multi_field',\r\n    es_fields: {\r\n      multi_field: { type: 'string', index: 'analyzed' },\r\n      untouched: { type: 'string', index: 'not_analyzed' }\r\n    }\r\n  },\r\n\r\n  // Geo point type\r\n  geo: {\r\n    type: String,\r\n    es_type: 'geo_point'\r\n  },\r\n\r\n  // Geo point type with lat_lon fields\r\n  geo_with_lat_lon: {\r\n    geo_point: {\r\n      type: String,\r\n      es_type: 'geo_point',\r\n      es_lat_lon: true\r\n    },\r\n    lat: { type: Number },\r\n    lon: { type: Number }\r\n  }\r\n\r\n  geo_shape: {\r\n    coordinates : [],\r\n    type: {type: String},\r\n    geo_shape: {\r\n      type:String,\r\n      es_type: \"geo_shape\",\r\n      es_tree: \"quadtree\",\r\n      es_precision: \"1km\"\r\n    }\r\n  }\r\n\r\n  // Special feature : specify a cast method to pre-process the field before indexing it\r\n  someFieldToCast : {\r\n    type: String,\r\n    es_cast: function(value){\r\n      return value + ' something added';\r\n    }\r\n  }\r\n\r\n});\r\n\r\n// Used as nested schema above.\r\nvar SubSchema = new Schema({\r\n  field1: {type: String},\r\n  field2: {type: String}\r\n});\r\n```\r\n\r\n### Geo mapping\r\nPrior to index any geo mapped data (or calling the synchronize),\r\nthe mapping must be manualy created with the createMapping (see above).\r\n\r\nNotice that the name of the field containing the ES geo data must start by\r\n'geo_' to be recognize as such.\r\n\r\n#### Indexing a geo point\r\n\r\n```javascript\r\nvar geo = new GeoModel({\r\n  /* … */\r\n  geo_with_lat_lon: { lat: 1, lon: 2}\r\n  /* … */\r\n});\r\n```\r\n\r\n#### Indexing a geo shape\r\n\r\n```javascript\r\nvar geo = new GeoModel({\r\n  …\r\n  geo_shape:{\r\n    type:'envelope',\r\n    coordinates: [[3,4],[1,2] /* Arrays of coord : [[lon,lat],[lon,lat]] */\r\n  }\r\n  …\r\n});\r\n```\r\n\r\nMapping, indexing and searching example for geo shape can be found in test/geo-test.js\r\n\r\nFor example, one can retrieve the list of document where the shape contain a specific\r\npoint (or polygon...)\r\n\r\n```javascript\r\nvar geoQuery = {\r\n      \"match_all\": {}\r\n    }\r\n\r\nvar geoFilter = {\r\n      geo_shape: {\r\n        geo_shape: {\r\n          shape: {\r\n            type: \"point\",\r\n            coordinates: [3,1]\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\nGeoModel.search(geoQuery, {filter: geoFilter}, function(err, res) { /* ... */ })\r\n```\r\n\r\n### Creating Mappings On Demand\r\nCreating the mapping is a **one time operation** and **should be called manualy**.\r\n\r\nA BookSchema as an example:\r\n\r\n```javascript\r\nvar BookSchema = new Schema({\r\n    title: {type:String, es_boost:2.0}\r\n  , author: {type:String, es_null_value:\"Unknown Author\"}\r\n  , publicationDate: {type:Date, es_type:'date'}\r\n\r\nBookSchema.plugin(mongoosastic);\r\nvar Book = mongoose.model('Book', BookSchema);\r\nBook.createMapping({\r\n  \"analysis\" : {\r\n    \"analyzer\":{\r\n      \"content\":{\r\n        \"type\":\"custom\",\r\n        \"tokenizer\":\"whitespace\"\r\n      }\r\n    }\r\n  }\r\n},function(err, mapping){\r\n  // do neat things here\r\n});\r\n\r\n```\r\nThis feature is still a work in progress. As of this writing you'll have\r\nto manage whether or not you need to create the mapping, mongoosastic\r\nwill make no assumptions and simply attempt to create the mapping. If\r\nthe mapping already exists, an Exception detailing such will be\r\npopulated in the `err` argument.\r\n\r\n\r\n## Queries\r\nThe full query DSL of Elasticsearch is exposed through the search\r\nmethod. For example, if you wanted to find all people between ages 21\r\nand 30:\r\n\r\n```javascript\r\nPerson.search({\r\n  range: {\r\n    age:{\r\n      from:21\r\n    , to: 30\r\n    }\r\n  }\r\n}, function(err, people){\r\n   // all the people who fit the age group are here!\r\n});\r\n\r\n```\r\nSee the Elasticsearch [Query DSL](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html) docs for more information.\r\n\r\nYou can also specify query options like [sorts](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html#search-request-sort)\r\n\r\n```javascript\r\nPerson.search({/* ... */}, {sort: \"age:asc\"}, function(err, people){\r\n  //sorted results\r\n});\r\n```\r\n\r\nAnd also [aggregations](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html):\r\n\r\n```javascript\r\nPerson.search({/* ... */}, {\r\n  aggs: {\r\n    'names': {\r\n      'terms': {\r\n        'field': 'name'\r\n      }\r\n    }\r\n  }\r\n}, function(err, results){\r\n  // results.aggregations holds the aggregations\r\n});\r\n```\r\n\r\nOptions for queries must adhere to the [javascript elasticsearch driver specs](https://www.elastic.co/guide/en/elasticsearch/client/javascript-api/current/api-reference.html#api-search).\r\n\r\n### Raw queries\r\nA full ElasticSearch query object can be provided to mongoosastic through `.esSearch()` method.\r\nIt can be useful when paging results. The query to be provided wraps the query object provided to `.search()` method and\r\naccepts the same options:\r\n\r\n```javascript\r\nvar rawQuery = {\r\n    from: 60,\r\n    size: 20,\r\n    query: /* query object as in .search() */\r\n};\r\n\r\nModel.esSearch(rawQuery, options, cb);\r\n```\r\n\r\nFor example:\r\n\r\n```javascript\r\nPerson.esSearch({\r\n  from: 60,\r\n  size: 20,\r\n  query: {\r\n    range: {\r\n      age:{\r\n        from:21,\r\n        to: 30\r\n      }\r\n    }\r\n  }\r\n}, function(err, people){\r\n   // only the 61st to 80th ranked people who fit the age group are here!\r\n});\r\n```\r\n\r\n### Hydration\r\nBy default objects returned from performing a search will be the objects\r\nas is in Elasticsearch. This is useful in cases where only what was\r\nindexed needs to be displayed (think a list of results) while the actual\r\nmongoose object contains the full data when viewing one of the results.\r\n\r\nHowever, if you want the results to be actual mongoose objects you can\r\nprovide {hydrate:true} as the second argument to a search call.\r\n\r\n```javascript\r\n\r\nUser.search(\r\n  {query_string: {query: 'john'}},\r\n  {hydrate: true},\r\n  function(err, results) {\r\n    // results here\r\n});\r\n\r\n```\r\n\r\nYou can also pass in a `hydrateOptions` object with information on\r\nhow to query for the mongoose object.\r\n\r\n```javascript\r\n\r\nUser.search(\r\n  {query_string: {query: 'john'}},\r\n  {\r\n    hydrate: true,\r\n    hydrateOptions: {select: 'name age'}\r\n  },\r\n  function(err, results) {\r\n    // results here\r\n});\r\n\r\n```\r\n\r\nOriginal ElasticSearch result data can be kept with `hydrateWithESResults` option. Documents are then enhanced with a\r\n`_esResult` property\r\n\r\n```javascript\r\n\r\nUser.search(\r\n  {query_string: {query: 'john'}},\r\n  {\r\n    hydrate: true,\r\n    hydrateWithESResults: true,\r\n    hydrateOptions: {select: 'name age'}\r\n  },\r\n  function(err, results) {\r\n    // results here\r\n    results.hits.hits.forEach(function(result) {\r\n      console.log(\r\n        'score',\r\n        result._id,\r\n        result._esResult._score\r\n      );\r\n    });\r\n});\r\n\r\n```\r\n\r\nBy default the `_esResult._source` document is skipped. It can be added with the option `hydrateWithESResults: {source: false}`.\r\n\r\n\r\n\r\nNote using hydrate will be a degree slower as it will perform an Elasticsearch\r\nquery and then do a query against mongodb for all the ids returned from\r\nthe search result.\r\n\r\nYou can also default this to always be the case by providing it as a\r\nplugin option (as well as setting default hydrate options):\r\n\r\n\r\n```javascript\r\nvar User = new Schema({\r\n    name: {type:String, es_indexed:true}\r\n  , email: String\r\n  , city: String\r\n})\r\n\r\nUser.plugin(mongoosastic, {hydrate:true, hydrateOptions: {lean: true}})\r\n```\r\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git://github.com/mongoosastic/mongoosastic.git"
  },
  "scripts": {
    "authors": "./scripts/update_authors.sh",
    "changelog": "changelog mongoosastic/mongoosastic latest -m",
    "coverage": "cat ./coverage/lcov.info | coveralls",
    "lint": "eslint lib test",
    "mocha": "mocha test/*-test.js",
    "test": "npm run lint && istanbul cover _mocha --report lcovonly -- test/*-test.js"
  },
  "tags": [
    "mongodb",
    "elasticsearch",
    "elastic search",
    "mongoose",
    "full text search"
  ],
  "version": "4.3.0"
}
